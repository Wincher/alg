'''
一条包含字母 A-Z 的消息通过以下方式进行了编码：
TEXT
'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。
示例 1：
TEXT
输入: "12"
输出: 2
解释: 它可以解码为 "AB" (1 2) 或者 "L" (12).
示例 2：
TEXT
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6).
'''
def numDecodings(s):
    """
    计算解码方法的总数
    """
    if not s:
        return 1  # 空字符串算作一种解码方式

    n = len(s)
    dp = [0] * (n + 1)  # dp[i] 表示 s[:i] 的解码方法总数
    dp[0] = 1  # 空字符串算作一种解码方式
    dp[1] = 1 if s[0] != '0' else 0  # 第一个字符的解码方式

    for i in range(2, n + 1):
        # 解码一个字符 (s[i-1])
        one_digit = int(s[i-1])
        if 1 <= one_digit <= 9:
            dp[i] += dp[i-1]

        # 解码两个字符 (s[i-2:i])
        two_digits = int(s[i-2:i])
        if 10 <= two_digits <= 26:
            dp[i] += dp[i-2]

    return dp[n]

# 示例
s1 = "12"
print(f"输入: {s1}, 输出: {numDecodings(s1)}")  # 输出: 输入: 12, 输出: 2

s2 = "226"
print(f"输入: {s2}, 输出: {numDecodings(s2)}")  # 输出: 输入: 226, 输出: 3

s3 = "06"
print(f"输入: {s3}, 输出: {numDecodings(s3)}") # 输出: 输入: 06, 输出: 0

'''
动态规划: 使用动态规划的思想来解决问题。 dp[i] 表示字符串 s 的前 i 个字符的解码方式总数。

初始化:

dp[0] = 1: 空字符串可以解码成空字符串，所以有一种解码方式。
dp[1]: 如果 s[0] 不为 '0'，则 dp[1] = 1，否则 dp[1] = 0 (因为 '0' 无法单独解码)。
递推公式: 对于 i >= 2，考虑两种情况：

解码一个字符 s[i-1]: 如果 1 <= int(s[i-1]) <= 9，则可以单独解码 s[i-1]，解码方式总数为 dp[i-1]。
解码两个字符 s[i-2:i]: 如果 10 <= int(s[i-2:i]) <= 26，则可以将 s[i-2:i] 合起来解码，解码方式总数为 dp[i-2]。
结果: dp[n] 就是字符串 s 的解码方式总数。

时间复杂度: O(N)，其中 N 是字符串的长度。 需要遍历字符串一次来填充 dp 数组。
空间复杂度: O(N)，使用了 dp 数组来存储中间结果。 可以优化到 O(1) 空间复杂度，只需要保存前两个状态即可。
'''
